## 4.4. Tokens|令牌

* 4.4.1. Supported Tokens
* 4.4.2. Supported Tokentypes
* 4.4.3. Token configuration




#### 4.4.2.9. Remote

The token type remote forwards the authentication request to another privacyIDEA Server.

When forwarding the authentication request, you can

* change the username
* change the resolver
* change the realm
* change the serial number

and mangle the password.

![enroll_remote](enroll_remote.png)

Enroll a Remote token

**Check the PIN locally**

If checked, the PIN of the token will be checked on the local server. If the PIN matches only the remaining part of the issued password will be sent to the remote privacyIDEA server.

**Remote Server**

The privacyIDEA server, to which the authentication request will be forwarded. The path /validate/check will be added automatically. So a sensible input would be https://my.other.server/.

**Remote Serial**

If the Remote Serial is specified the given password will be checked against the serial number on the remote privacyIDEA server. Usernames will be ignored.

**Remote User**

When forwarding the request to the remote server, the authentication request will be issued for this user.

**Remote Realm**

When forwarding the request to the remote server, the authentication request will be issued for this realm.

**Remote Resolver**

When forwarding the request to the remote server, the authentication request will be issued for this resolver.

> Note:
> 
> You can use Remote Serial to forward the request to a central privacyIDEA server, that only knows tokens but has no knowledge of users. Or you can use Remote Serial to forward the request to an existing to on localhost thus adding a second user to the same token.

#### 4.4.2.10. SMS

The token type sms sends the OTP value via an SMS service. You can configure the SMS service in SMS OTP Token.

![enroll_sms](enroll_sms.png)

Enroll an SMS token

When enrolling an SMS token, you only need to specify the mobile phone number.

SMS token is a challenge response token. I.e. when sending the OTP PIN in the first authentication request, the sending of the SMS will be triggered and in a second authentication request the OTP value from the SMS needs to be presented.

For a more detailed insight see the code documentation SMS Token.

#### 4.4.2.11. Spass - Simple Pass Token

The OTP component of the spass token is always true. Thus the user only needs to provide the OTP pin or the userstore password - depending on the policy settings.

For a more detailed insight see the code documentation SPass Token.

#### 4.4.2.12. SSH Keys

The token type sshkey is the public SSH key, that you can upload and assign to a user. The SSH key is only used for the application type SSH in conjunction with the Client machines concept.

A user or the administrator can upload the public SSH key and assign to a user.

![sshkey](sshkey.png)

Enroll an SSH key token

Paste the SSH key into the text area. The comment in the SSH key will be used as token comment. You can assign the SSH key to a user and then use the SSH key in Application Definitions SSH.

> Note:
> 
> This way you can manage SSH keys centrally, as you do not need to distribute the SSH keys to all machines. You rather store the SSH keys centrally in privacyIDEA and use **privacyidea-authorizedkeys** to fetch the keys in real time during the login process.

#### 4.4.2.13. TiQR

Starting with version 2.6 privacyIDEA supports the TiQR token. The TiQR token is a smartphone token, that can be used to login by only scanning a QR code.

The token is also enrolled by scanning a QR code.

![enroll_tiqr_1](enroll_tiqr_1.png)

Choose a user for the TiQR token

You can only enroll a TiQR token, when a user is selected.

> Note:
> 
> You can not enroll a TiQR token without assign the token to a user.

![enroll_tiqr_2](enroll_tiqr_2.png)

For more technical information about the TiQR token please see TiQR Token.

#### 4.4.2.14. TOTP

The TOTP token is - together with the HOTP - the most common token. The TOTP Algorithm is defined in RFC6238. The TOTP token is a time based token. Roughly speaking the TOTP algorithm is the same algorithm like the HOTP, where the event based counter is replaced by the unix timestamp.

The TOTP algorithm has some parameter, like if the generated OTP value will be 6 digits or 8 digits or if the SHA1 oder the SHA256 hashing algorithm is used and the timestep being 30 or 60 seconds.

##### 4.4.2.14.1. Hardware tokens

The information about preseeded token and seedable tokens is the same as described in the section about HOTP.

The only available seedable pushbutton TOTP token is the SafeNet eToken Pass. The Yubikey can be used as a TOTP token, but only in conjunction with a smartphone app, since the yubikey has not its own clock.

##### 4.4.2.14.2. Software tokens

###### 4.4.2.14.2.1. Experiences

The Google Authenticator and the FreeOTP token can be enrolled easily in TOTP mode using the QR-Code enrollment Feature.

The Google Authenticator is available for iOS, Android and Blackberry devices.

##### 4.4.2.14.3. Enrollment

Default settings for TOTP tokens can be configured at TOTP Token Config.

The enrollment is the same as described in HOTP. However, when enrolling TOTP token, you can specify some additional parameters.

![enroll_totp](enroll_totp.png)

Enroll an TOTP token

#### 4.4.2.15. U2F

Starting with version 2.7 privacyIDEA supports U2F tokens. The administrator or the user himself can register a U2F device and use this U2F token to login to the privacyIDEA web UI or to authenticate at applications.

When enrolling the token a key pair is generated and the public key is sent to privacyIDEA. During this process the user needs to prove that he is present by either pressing the button (Yubikey) or by replugging the device (Plug-up token).

The device is identified and assigned to the user.

> Note:
> 
> This is a normal token object which can also be reassigned to another user.
> 
> Note:
> 
> As the key pair is only generated virtually, you can register one physical device for several users.

For configuring privacyIDEA for the use of U2F token, please see U2F Token Config.

For further details and for information how to add this to your application you can see the code documentation at U2F Token.

#### 4.4.2.16. Yubico

The token type yubico authenticates against the Yubico Cloud mode. You need to configure this at Yubico Cloud mode.

![enroll_yubico](enroll_yubico.png)

Enroll a Yubico token

The token is enrolled by simply saving the Yubikey token ID in the token object. You can either enter the 12 digit ID or you can simply press the Yubikey button in the input field, which will also assign the token.

#### 4.4.2.17. Yubikey

The Yubikey is initialized with privacyIDEA and works in Yubicos own AES mode. It outputs a 44 character OTP value, consisting of a 12 character prefix and a 32 character OTP. But in contrast to the Yubico Cloud mode, in this mode the secret key is contained within the token and your own privacyIDEA installation.

If you have the time and care about privacy, you should prefer the Yubikey AES mode over the Yubico Cloud mode.

There are three possible ways to enroll a Yubikey token.

> Note:
> 
> We recommend that you use the privacyidea command line client, to initialize the Yubikeys. You can use the mass enrollment, which eases the process of initializing a whole bunch of tokens.

Run the command like this:

```
privacyidea -U https://your.privacyidea.server -a admin token \
yubikey_mass_enroll --yubimode YUBICO
```

This command initializes the token and stores the AES secret and prefix in privacyidea, so the token is immediatly useful. You can choose the slot with --yubislot. For further help call privcyidea yubikey_mass_enroll with the --help option.

The second way to enroll a yubikey token is also using yubikey_mass_enroll, but with the option --filename to write to token configuration into the specified file. The resulting file can then be imported into privacyidea: Select Tokens -> Import Tokens, select “OATH CSV” and the file you just created.

Third and last you can use this dialog to enroll a Yubikey AES mode token, if you have initialized the yubikey with the external ykpersonalize tool.

![enroll_yubikey](enroll_yubikey.png)

Enroll a Yubikey AES mode token

##### 4.4.2.17.1. Redirect api url to privacyideas /ttype/yubikey

Yubico servers use /wsapi/2.0/verify as the path in the validation URL. Some tools (e.g. Kolab 2fa) let the user/admin change the api host, but not the rest of the URL. Let’s redirect the api URL to privacyideas /ttype/yubikey - you’ll need to enable the following two lines in /etc/apache2/site-enabled/privacyidea.conf:

```
RewriteEngine on RewriteRule “^/wsapi/2.0/verify” “/ttype/yubikey” [PT]
```

If you use nginx there is a similar line provided as a comment to the nginx configuration as well.

### 4.4.3. Token configuration

Each token type can provide its own configuration dialog.

In this configuration dialog you can define default values for these token types.

![token-config](token-config.png)

Token Configuration: SMS

#### 4.4.3.1. Email OTP Token

![email](email.png)

Email Token configuration

The Email OTP token creates a OTP value and sends this OTP value to the email address of the uses. The Email can be triggered by authenticating with only the OTP PIN:

##### 4.4.3.1.1. First step

In the first step the user will enter his OTP PIN and the sending of the Email is triggered. The user is denied the access.

##### 4.4.3.1.2. Seconds step

In the second step the user authenticates with the OTP PIN and the OTP value he received via Email. The user is granted access.

Alternatively the user can authenticate with the transaction_id that was sent to him in the response during the first step and only the OTP value. The transaction_id assures that the user already presented the first factor (OTP PIN) successfully.

##### 4.4.3.1.3. Configuration Parameters

You can configure the mail parameters for the Email Token centrally at Config -> Tokens -> Email.

**Mail Server**

The name or IP address of the mail server that is used to send emails.

**Port**

The port of the mail server.

**Mail User**

If the mail server requires authentication you need to enter a username. If no username is entered, no authentication is performed on the mail server.

**Mail User Password**

The password of the mail username to send emails.

**Mail Sender Address**

The mail address of the mail sender. This needs to correspond to the Mail User.

**OTP validity time**

This is the time in seconds, for how long the sent OTP value is valid. If a user tries to authenticate with the sent OTP value after this time, authentication will fail.

**Use TLS**

Whether the mail server should use TLS.

#### 4.4.3.2. HOTP Token Config

![](hotp.png)

HOTP Token configuration

#### 4.4.3.3. SMS OTP Token

The SMS OTP token creates a OTP value and sends this OTP value to the mobile phone of the user. The SMS can be triggered by authenticating with only the OTP PIN:

##### 4.4.3.3.1. First step

In the first step the user will enter his OTP PIN and the sending of the SMS is triggered. The user is denied the access.

##### 4.4.3.3.2. Second step

In the second step the user authenticates with the OTP PIN and the OTP value he received via SMS. The user is granted access.

Alternatively the user can authenticate with the transaction_id that was sent to him in the response during the first step and only the OTP value. The transaction_id assures that the user already presented the first factor (OTP PIN) successfully.

A python SMS provider module defines how the SMS is sent. This can be done using an HTTP SMS Gateway. Most services like Clickatel or sendsms.de provide such a simple HTTP gateway. Another possibility is to send SMS via sipgate, which provides an XMLRPC API. The third possibility is to send the SMS via an SMTP gateway. The proovider receives a specially designed email and sends the SMS accordingly. The last possibility to send SMS is to use an attached GSM modem.

In the field SMS provider you can enter the SMS provider module, you wish to use. In the empty field hit the arrow-down key and you will get a list of the ready made modules.

In the SMS configuration text area you can enter the configuration, which contents is very much dependent on the selected provider module.

The HTTP and the Sipgate module provide a preset-button, which give you an idea of the configuration.

##### 4.4.3.3.3. HTTP provider

The HTTP provider can be used for any SMS gateway that provides a simple HTTP POST or GET request.

The following parameters can be used:

**URL**

This is the URL for the gateway.

**HTTP_Method**

Can be GET or POST.

**USERNAME and PASSWORD**

These are the username and the password if the HTTP request requires basic authentication.

**SMS_PHONENUMBER_KEY**

This is the name of the HTTP parameter that holds the mobile phone number of the recipient.

**SMS_TEXT_KEY**

This is the name of the HTTP parameter that holds the SMS text.

**RETURN_SUCCESS**

You can either use RETURN_SUCCESS or RETURN_FAIL. If the text of RETURN_SUCCESS is found in the HTTP response of the gateway privacyIDEA assumes that the SMS was sent successfully.

**RETURN_FAIL**

If the text of RETURN_FAIL is found in the HTTP response of the gateway privacyIDEA assumes that the SMS could not be sent and an error occurred.

**PROXY**

You can specify a proxy to connect to the HTTP gateway.

**PARAMETER**

This can contain a dictionary of arbitrary fixed additional parameters. Usually this would also contain an ID or a password to identify you as a sender.

###### 4.4.3.3.3.1. Example:

In case of the Clicaktell provider the configuration will look like this:

```

{ "URL" : "http://api.clickatell.com/http/sendmsg",

 "PARAMETER" : {

 "user":"YOU",

 "password":"YOUR PASSWORD",

 "api_id":"YOUR API ID"

 },

 "SMS_TEXT_KEY":"text",

 "SMS_PHONENUMBER_KEY":"to",

 "HTTP_Method":"GET",

 "RETURN_SUCCESS" : "ID"

}

```

This will consturct an HTTP GET request like this:

```

http://api.clickatell.com/http/sendmsg?user=YOU&password=YOU&\

 api_id=YOUR API ID&text=....&to=....

```

where text and to will contain the OTP value and the mobile phone number. privacyIDEA will assume a successful sent SMS if the response contains the text “ID”.

##### 4.4.3.3.4. Sipgate provider

The sipgate provider connects to https://samurai.sipgate.net/RPC2 and takes only two arguments USERNAME and PASSWORD. The arguments have to be passed in a dictionary like this:

```

{ "USERNAME" : "youruser",

 "PASSWORD" : "yourpassword" }

```

> Note:
> 
> You need to use double quotes around the values.

If you activate debug log level you will see the submitted SMS and the response content from the Sipgate gateway.

##### 4.4.3.3.5. SMTP provider

The SMTP provider sends an email to an email gateway. This is a specified, fixed mail address.

The mail should contain the phone number and the OTP value. The email gateway will send the OTP via SMS to the given phone number.

Up to version 2.9 the SMTP provider needs to be configured like this:

```

{"MAILSERVER": "localhost:25",

 "MAILTO": "recp@example.com",

 "MAILSENDER": "pi@example.com",

 "MAILUSER": "username",

 "MAILPASSWORD": "sosecret"}

```

Optional parameters are MAILUSER and MAILPASSWORD if the mailserver to send the email needs authentication.

This configuration is DEPRECATED.

Starting with privacyIDEA 2.10 you can use the system wide SMTP server configuration. The configuration looks like this:

```

{"MAILTO": "recp@example.com",

 "IDENTIFIER": "name-of-smtp-config"}

```

The default SUBJECT is set to <phone> and the default BODY to <otp>. You may change the SUBJECT and the BODY accordingly.

#### 4.4.3.4. TiQR Token Config

![tiqr](tiqr.png)

TiQR Token configuration

##### 4.4.3.4.1. TiQR Registration Server

You need at least enter the TiQR Registration Server. This is the URL of your privacyIDEA installation, that can be reached from the smartphone during enrollment. So your smartphone needs to be on the same LAN (WLAN) like the privacyIDEA server or the enrollment URL needs to be accessible from the internet.

You also need to specify the path, which is usually /ttype/tiqr.

During enrollment the parameter action=metadata and action=enrollment is added.

> Note:
> 
> We do not recommend putting the registration URL on the internet.

##### 4.4.3.4.2. TiQR Authentication Server

This is the URL that is used during authentication. This can be another URL than the Registration Server. If it is left blank, the URL of the Registration Server is used.

During authentication the parameter operation=login is added.

#### 4.4.3.5. TOTP Token Config

![totp](totp.png)

TOTP Token configuration

#### 4.4.3.6. U2F Token Config

##### 4.4.3.6.1. AppId

You need to configure the AppId of the privacyIDEA server. The AppId is define in the FIDO specification <span id="id3">[[1]](#fido)</span>.

The AppId is the URL of your privacyIDEA and used to find or create the right key pair on the U2F device. The AppId must correspond the the URL that is used to call the privacyIDEA server.

> Note:
> 
> if you register a U2F device with an AppId https://privacyidea.example.com and try to authenticate at https://10.0.0.1, the U2F authentication will fail.
> 
> Note:
> 
> The AppId must not contain any trailing slashes!

##### 4.4.3.6.2. Facets

If specifying the AppId as the FQDN you will only be able to authenticate at the privacyIDEA server itself or at any application in a sub directory on the privacyIDEA server. This is OK, if you are running a SAML IdP on the same server.

But if you also want to use the U2F token with other applications, you need to specify the AppId like this:

https://privacyidea.example.com/pi-url/ttype/u2f

pi-url is the path, if you are running the privacyIDEA instance in a sub folder.

/ttype/u2f is the endpoint that returns a trusted facets list. Trusted facets are other hosts in the domain example.com. You need to define a policy that contains a list of the other hosts (u2f_facets).

For more information on AppId and trusted facets see <span id="id4">[[1]](#fido)</span>.

For further details and for information how to add U2F to your application you can see the code documentation at U2F Token.

##### 4.4.3.6.3. Workflow

You can use a U2F token on privacyIDEA and other hosts in the same Domain. To do so you need to do the following steps:

1. Configure the AppId to reflect your privacyIDEA server:  
https://pi.your-network.com/ttype/u2f  
Add the path /ttype/u2f is crucial. Otherwise privacyIDEA will not return the trusted facets.
2. Define a policy with the list of trusted facets. (see u2f_facets). Add the FQDNs of the hosts to the policy:  
saml.your-network.com otherapp.your-network.com vpn.your-network.com  
> Note:
> 
> The privacyIDEA plugin for simpleSAMLphp supports U2F with privacyIDEA starting with version 2.8.
3. Now register a U2F token on https://pi.your-network.com. Due to the trusted facets you will also be able to use this U2F token on the other hosts.
4.Now got to https://saml.your-network.com and you will be able to authenticate with the very U2F token without any further registering.

**Footnotes**

> [1] ([1](#id3), [2](#id4)): https://fidoalliance.org/specs/fido-u2f-v1.0-nfc-bt-amendment-20150514/fido-appid-and-facets.html<span id="fido"></span>

#### 4.4.3.7. Yubico Cloud mode

The Yubico Cloud mode sends the One Time Password emitted by the yubikey to the Yubico Cloud service or another (possibly self hosted) validation server.

![yubico](yubico.png)

Configure the Yubico Cloud mode

To contact the Yubico Cloud service you need to get an API key and a Client ID from Yubico and enter these here in the config dialog. In that case you can leave the Yubico URL blank and privacyidea will use the Yubico servers.

You can use another validation host, e.g. a self hosted validation server. If you use privacyidea token type yubikey, you can use the URL https://<privacyideaserver>/ttype/yubikey, other validation servers might use https://<validationserver>/wsapi/2.0/verify. You’ll get the Client ID and API key from the configuration of your validation server.

You can get your own API key at <span id="id5>[[1]](#yubico)</span>.

> [[1]](#id5): https://upgrade.yubico.com/getapikey/<span id="yubico"></span>

#### 4.4.3.8. Yubikey AES mode

The Yubico AES mode uses the same kind of token as the Yubico Cloud service, but validates the OTP in your local privacyidea server. So the secrets stay local to your system and are not stored in Yubico’s Cloud service.

![yubikey](yubikey.png)

Configure the Yubikey AES mode

You can have more than one Client with a Client ID connect to your server. The Client ID starts with yubikey.apiid. and is followed by the API ID, which you’ll need to configure your clients. With create new API key you generate a new API for that specific Client ID. The API key is used to sign the validation request sent to the server and the server signs the answer too. That way tampering or MITM attacks might be detected. It is possible to validate token without the API key, but then the request and answer can’t be verify against the key. It is useful to use HTTPS for your validation requests, but this is another kind of protection.

OTP validation can either use the privacyidea API /validate/check or the Yubikey validation protocol /ttype/yubikey or - if enabled in your webserver configuration - /wsapi/2.0/verify.
