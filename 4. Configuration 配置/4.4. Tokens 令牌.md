## 4.4. Tokens|令牌

* [4.4.1. Supported Tokens](4.4.1. Supported Tokens 支持的令牌.md)
* [4.4.2. Supported Tokentypes](4.4.2. Supported Tokentypes 支持的令牌类型.md)
* [4.4.3. Token configuration](4.4.3. Token configuration 令牌配置.md)



#### 4.4.3.1. Email OTP Token

![email](email.png)

Email Token configuration

The Email OTP token creates a OTP value and sends this OTP value to the email address of the uses. The Email can be triggered by authenticating with only the OTP PIN:

##### 4.4.3.1.1. First step

In the first step the user will enter his OTP PIN and the sending of the Email is triggered. The user is denied the access.

##### 4.4.3.1.2. Seconds step

In the second step the user authenticates with the OTP PIN and the OTP value he received via Email. The user is granted access.

Alternatively the user can authenticate with the transaction_id that was sent to him in the response during the first step and only the OTP value. The transaction_id assures that the user already presented the first factor (OTP PIN) successfully.

##### 4.4.3.1.3. Configuration Parameters

You can configure the mail parameters for the Email Token centrally at Config -> Tokens -> Email.

**Mail Server**

The name or IP address of the mail server that is used to send emails.

**Port**

The port of the mail server.

**Mail User**

If the mail server requires authentication you need to enter a username. If no username is entered, no authentication is performed on the mail server.

**Mail User Password**

The password of the mail username to send emails.

**Mail Sender Address**

The mail address of the mail sender. This needs to correspond to the Mail User.

**OTP validity time**

This is the time in seconds, for how long the sent OTP value is valid. If a user tries to authenticate with the sent OTP value after this time, authentication will fail.

**Use TLS**

Whether the mail server should use TLS.

#### 4.4.3.2. HOTP Token Config

![](hotp.png)

HOTP Token configuration

#### 4.4.3.3. SMS OTP Token

The SMS OTP token creates a OTP value and sends this OTP value to the mobile phone of the user. The SMS can be triggered by authenticating with only the OTP PIN:

##### 4.4.3.3.1. First step

In the first step the user will enter his OTP PIN and the sending of the SMS is triggered. The user is denied the access.

##### 4.4.3.3.2. Second step

In the second step the user authenticates with the OTP PIN and the OTP value he received via SMS. The user is granted access.

Alternatively the user can authenticate with the transaction_id that was sent to him in the response during the first step and only the OTP value. The transaction_id assures that the user already presented the first factor (OTP PIN) successfully.

A python SMS provider module defines how the SMS is sent. This can be done using an HTTP SMS Gateway. Most services like Clickatel or sendsms.de provide such a simple HTTP gateway. Another possibility is to send SMS via sipgate, which provides an XMLRPC API. The third possibility is to send the SMS via an SMTP gateway. The proovider receives a specially designed email and sends the SMS accordingly. The last possibility to send SMS is to use an attached GSM modem.

In the field SMS provider you can enter the SMS provider module, you wish to use. In the empty field hit the arrow-down key and you will get a list of the ready made modules.

In the SMS configuration text area you can enter the configuration, which contents is very much dependent on the selected provider module.

The HTTP and the Sipgate module provide a preset-button, which give you an idea of the configuration.

##### 4.4.3.3.3. HTTP provider

The HTTP provider can be used for any SMS gateway that provides a simple HTTP POST or GET request.

The following parameters can be used:

**URL**

This is the URL for the gateway.

**HTTP_Method**

Can be GET or POST.

**USERNAME and PASSWORD**

These are the username and the password if the HTTP request requires basic authentication.

**SMS_PHONENUMBER_KEY**

This is the name of the HTTP parameter that holds the mobile phone number of the recipient.

**SMS_TEXT_KEY**

This is the name of the HTTP parameter that holds the SMS text.

**RETURN_SUCCESS**

You can either use RETURN_SUCCESS or RETURN_FAIL. If the text of RETURN_SUCCESS is found in the HTTP response of the gateway privacyIDEA assumes that the SMS was sent successfully.

**RETURN_FAIL**

If the text of RETURN_FAIL is found in the HTTP response of the gateway privacyIDEA assumes that the SMS could not be sent and an error occurred.

**PROXY**

You can specify a proxy to connect to the HTTP gateway.

**PARAMETER**

This can contain a dictionary of arbitrary fixed additional parameters. Usually this would also contain an ID or a password to identify you as a sender.

###### 4.4.3.3.3.1. Example:

In case of the Clicaktell provider the configuration will look like this:

```

{ "URL" : "http://api.clickatell.com/http/sendmsg",

 "PARAMETER" : {

 "user":"YOU",

 "password":"YOUR PASSWORD",

 "api_id":"YOUR API ID"

 },

 "SMS_TEXT_KEY":"text",

 "SMS_PHONENUMBER_KEY":"to",

 "HTTP_Method":"GET",

 "RETURN_SUCCESS" : "ID"

}

```

This will consturct an HTTP GET request like this:

```

http://api.clickatell.com/http/sendmsg?user=YOU&password=YOU&\

 api_id=YOUR API ID&text=....&to=....

```

where text and to will contain the OTP value and the mobile phone number. privacyIDEA will assume a successful sent SMS if the response contains the text “ID”.

##### 4.4.3.3.4. Sipgate provider

The sipgate provider connects to https://samurai.sipgate.net/RPC2 and takes only two arguments USERNAME and PASSWORD. The arguments have to be passed in a dictionary like this:

```

{ "USERNAME" : "youruser",

 "PASSWORD" : "yourpassword" }

```

> Note:
> 
> You need to use double quotes around the values.

If you activate debug log level you will see the submitted SMS and the response content from the Sipgate gateway.

##### 4.4.3.3.5. SMTP provider

The SMTP provider sends an email to an email gateway. This is a specified, fixed mail address.

The mail should contain the phone number and the OTP value. The email gateway will send the OTP via SMS to the given phone number.

Up to version 2.9 the SMTP provider needs to be configured like this:

```

{"MAILSERVER": "localhost:25",

 "MAILTO": "recp@example.com",

 "MAILSENDER": "pi@example.com",

 "MAILUSER": "username",

 "MAILPASSWORD": "sosecret"}

```

Optional parameters are MAILUSER and MAILPASSWORD if the mailserver to send the email needs authentication.

This configuration is DEPRECATED.

Starting with privacyIDEA 2.10 you can use the system wide SMTP server configuration. The configuration looks like this:

```

{"MAILTO": "recp@example.com",

 "IDENTIFIER": "name-of-smtp-config"}

```

The default SUBJECT is set to <phone> and the default BODY to <otp>. You may change the SUBJECT and the BODY accordingly.

#### 4.4.3.4. TiQR Token Config

![tiqr](tiqr.png)

TiQR Token configuration

##### 4.4.3.4.1. TiQR Registration Server

You need at least enter the TiQR Registration Server. This is the URL of your privacyIDEA installation, that can be reached from the smartphone during enrollment. So your smartphone needs to be on the same LAN (WLAN) like the privacyIDEA server or the enrollment URL needs to be accessible from the internet.

You also need to specify the path, which is usually /ttype/tiqr.

During enrollment the parameter action=metadata and action=enrollment is added.

> Note:
> 
> We do not recommend putting the registration URL on the internet.

##### 4.4.3.4.2. TiQR Authentication Server

This is the URL that is used during authentication. This can be another URL than the Registration Server. If it is left blank, the URL of the Registration Server is used.

During authentication the parameter operation=login is added.

#### 4.4.3.5. TOTP Token Config

![totp](totp.png)

TOTP Token configuration

#### 4.4.3.6. U2F Token Config

##### 4.4.3.6.1. AppId

You need to configure the AppId of the privacyIDEA server. The AppId is define in the FIDO specification <span id="id3">[[1]](#fido)</span>.

The AppId is the URL of your privacyIDEA and used to find or create the right key pair on the U2F device. The AppId must correspond the the URL that is used to call the privacyIDEA server.

> Note:
> 
> if you register a U2F device with an AppId https://privacyidea.example.com and try to authenticate at https://10.0.0.1, the U2F authentication will fail.
> 
> Note:
> 
> The AppId must not contain any trailing slashes!

##### 4.4.3.6.2. Facets

If specifying the AppId as the FQDN you will only be able to authenticate at the privacyIDEA server itself or at any application in a sub directory on the privacyIDEA server. This is OK, if you are running a SAML IdP on the same server.

But if you also want to use the U2F token with other applications, you need to specify the AppId like this:

https://privacyidea.example.com/pi-url/ttype/u2f

pi-url is the path, if you are running the privacyIDEA instance in a sub folder.

/ttype/u2f is the endpoint that returns a trusted facets list. Trusted facets are other hosts in the domain example.com. You need to define a policy that contains a list of the other hosts (u2f_facets).

For more information on AppId and trusted facets see <span id="id4">[[1]](#fido)</span>.

For further details and for information how to add U2F to your application you can see the code documentation at U2F Token.

##### 4.4.3.6.3. Workflow

You can use a U2F token on privacyIDEA and other hosts in the same Domain. To do so you need to do the following steps:

1. Configure the AppId to reflect your privacyIDEA server:  
https://pi.your-network.com/ttype/u2f  
Add the path /ttype/u2f is crucial. Otherwise privacyIDEA will not return the trusted facets.
2. Define a policy with the list of trusted facets. (see u2f_facets). Add the FQDNs of the hosts to the policy:  
saml.your-network.com otherapp.your-network.com vpn.your-network.com  
> Note:
> 
> The privacyIDEA plugin for simpleSAMLphp supports U2F with privacyIDEA starting with version 2.8.
3. Now register a U2F token on https://pi.your-network.com. Due to the trusted facets you will also be able to use this U2F token on the other hosts.
4.Now got to https://saml.your-network.com and you will be able to authenticate with the very U2F token without any further registering.

**Footnotes**

> [1] ([1](#id3), [2](#id4)): https://fidoalliance.org/specs/fido-u2f-v1.0-nfc-bt-amendment-20150514/fido-appid-and-facets.html<span id="fido"></span>

#### 4.4.3.7. Yubico Cloud mode

The Yubico Cloud mode sends the One Time Password emitted by the yubikey to the Yubico Cloud service or another (possibly self hosted) validation server.

![yubico](yubico.png)

Configure the Yubico Cloud mode

To contact the Yubico Cloud service you need to get an API key and a Client ID from Yubico and enter these here in the config dialog. In that case you can leave the Yubico URL blank and privacyidea will use the Yubico servers.

You can use another validation host, e.g. a self hosted validation server. If you use privacyidea token type yubikey, you can use the URL https://<privacyideaserver>/ttype/yubikey, other validation servers might use https://<validationserver>/wsapi/2.0/verify. You’ll get the Client ID and API key from the configuration of your validation server.

You can get your own API key at <span id="id5>[[1]](#yubico)</span>.

> [[1]](#id5): https://upgrade.yubico.com/getapikey/<span id="yubico"></span>

#### 4.4.3.8. Yubikey AES mode

The Yubico AES mode uses the same kind of token as the Yubico Cloud service, but validates the OTP in your local privacyidea server. So the secrets stay local to your system and are not stored in Yubico’s Cloud service.

![yubikey](yubikey.png)

Configure the Yubikey AES mode

You can have more than one Client with a Client ID connect to your server. The Client ID starts with yubikey.apiid. and is followed by the API ID, which you’ll need to configure your clients. With create new API key you generate a new API for that specific Client ID. The API key is used to sign the validation request sent to the server and the server signs the answer too. That way tampering or MITM attacks might be detected. It is possible to validate token without the API key, but then the request and answer can’t be verify against the key. It is useful to use HTTPS for your validation requests, but this is another kind of protection.

OTP validation can either use the privacyidea API /validate/check or the Yubikey validation protocol /ttype/yubikey or - if enabled in your webserver configuration - /wsapi/2.0/verify.
