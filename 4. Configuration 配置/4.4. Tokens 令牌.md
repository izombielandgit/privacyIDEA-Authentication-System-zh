## 4.4. Tokens|令牌

### 4.4.1. Supported Tokens

privacyIDEA supports a wide variety of tokens by different hardware vendors. It also supports token apps on the smartphone.

Tokens not listed, will be probably supported, too, since most tokens use standard algorithms.

If in doubt drop your question on the mailing list.

#### 4.4.1.1. Hardware Tokens

The following hardware tokens are known to work well.

**Yubikey**. The Yubikey is supported in all modes: AES (Yubikey), HOTP and Yubico Cloud. You can initialize the Yubikey yourself, so that the secret key is not known to the vendor.

**eToken Pass**. The eToken Pass is a push button token by SafeNet. It can be initialized with a special hardware device. Or you get a seed file, that you need to import to privacyIDEA. The eToken Pass can run as HOTP or TOTP token.

**eToken NG OTP**. The eToken NG OTP is a push button token by SafeNet. As it has a USB connector, you can initialize the token via the USB connector. Thus the hardware vendor does not know the secret key.

**DaPlug**. The DaPlug token is similar to the Yubikey and can be initialized via the USB connector. The secret key is not known to the hardware vendor.

**Smartdisplayer OTP Card**. This is a push button card. It features an eInk display, that can be read very good in all light condition at all angles. The Smartdisplayer OTP card is initialized at the factory and you get a seed file, that you need to import to privacyIDEA.

**Feitian**. The C100 and C200 tokens are classical, reasonably priced push button tokens. The C100 is an HOTP token and the C200 a TOTP token. These tokens are initialized at the factory and you get a seed file, that you need to import to privacyIDEA.

**U2F**. The Yubikey and the Daplug token are known U2F devices to work well with privacyIDEA. See U2F.

#### 4.4.1.2. Smartphone Apps

**Google Authenticator**. The Google Authenticator is working well in HOTP and TOTP mode. If you choose “Generate OTP Key on the Server” durcing enrollment, you can scan a QR Code with the Google Authenticator. See Enrolling your first token to learn how to do this.

**FreeOTP**. privacyIDEA is known to work well with the FreeOTP App. The FreeOTP App is a TOTP token. So if you scan the QR Code of an HOTP token, the OTP will not validate.

**mOTP**. Several mOTP Apps like “Potato”, “Token2” or “DroidOTP” are supported.

### 4.4.2. Supported Tokentypes

At the moment the following tokentypes are supported:

* HOTP - event based One Time Password tokens based on RFC4225.
* TOTP - time based One Time Password tokens based on RFC6238.
* mOTP - time based One Time Password tokens for mobile phones based on an a public Algorithm.
* Paper Token - event based One Time Password tokens that get you list of one time passwords on a sheet of paper.
* Questionnaire Token - A token that contains a list of answered questions. During authentication a random question is presented as challenge from the list of answered questions is presented. The user must give the right answer.
* EMail - A token that sends the OTP value to the EMail address of the user.
* Four Eyes - Meta token that can be used to create a Two Man Rule.
* password - A password token used for losttoken scenario.
* Registration - A special token type used for enrollment scenarios (see Registration Code).
* Simple Pass - A token that only consists of the Token PIN.
* Certificates - A token that represents a client certificate.
* SSH Keys - An SSH public key that can be managed and used in conjunction with the Client machines concept.
* Remote - A virtual token that forwards the authentication request to another privacyIDEA server.
* RADIUS - A virtual token that forwards the authentication request to a RADIUS server.
* SMS - A token that sends the OTP value to the mobile phone of the user.
* Spass - Simple Pass Token - The simple pass token. A token that has no OTP component and just consists of the OTP pin or (if otppin=userstore is set) of the userstore password.
* TiQR - A Smartphone token that can be used to login by only scanning a QR code.
* U2F - A U2F device as specified by the FIDO Alliance. This is a USB device to be used for challenge response authentication.
* Yubico - A Yubikey hardware that authenticates against the Yubico Cloud service.
* Yubikey - A Yubikey hardware initialized in the AES mode, that authenticates against privacyIDEA.
* Daplug - A hardware OTP token similar to the Yubikey.

The Tokentypes:

#### 4.4.2.1. Four Eyes

Starting with version 2.6 privacyIDEA supports 4 Eyes Token. This is a meta token, that can be used to define, that two or more token must be used to authenticate. This way, you can set up a “two man rule”.

You can define, from which realm how many unique tokens need to be present, when authenticating:

![enroll_4eyes](enroll_4eyes.png)

Enroll a 4 eyes token

In this example authentication will only be possbile if at least two tokens from realm2 and one token from realm sqlite are present.

Authentication is done by concatenating the OTP PINs and the OTP values of all tokens. The concatenation is split by the separator character.

It does not matter, in which order the tokens from the realms are entered.

Example

Authentication as:

```
username: "root@r2"
password: "pin123456 secret789434 key098123"
```

The three blocks separated by the blank are checked, if they match tokens in the realms realm2 and sqlite.

The response looks like this in case of success:

```
{
  "detail": {
    "message": "matching 1 tokens",
    "serial": "PI4E000219E1",
    "type": "4eyes"
  },
  "id": 1,
  "jsonrpc": "2.0",
  "result": {
    "status": true,
    "value": true
  },
  "version": "privacyIDEA 2.6dev0",
  "versionnumber": "2.6dev0"
}
```

In case of a failed authentication the response looks like this:

```
{
  "detail": {
    "foureyes": "Only found 0 tokens in realm themis",
    "message": "wrong otp value",
    "serial": "PI4E000219E1",
    "type": "4eyes"
  },
  "id": 1,
  "jsonrpc": "2.0",
  "result": {
    "status": true,
    "value": false
  },
  "version": "privacyIDEA 2.6dev0",
  "versionnumber": "2.6dev0"
}
```

> Note:
> 
> The 4Eyes Token verifies that unique tokens from each realm are used. I.e. if you require 2 tokens from a realm, you can not use the same token twice.
> 
> Warning:
> 
> But it does not verify, if these two unique tokens belong to the same user. Thus you should create a poliy, that in such a realm a user may only have on token.

#### 4.4.2.2. Certificates

Starting with version 2.3 privacyIDEA supports certificates. A user can

* upload a certificate request,
* upload a certificate or
* he can generate a certificate request in the browser.

privacyIDEA does not sign certificate requests itself but connects to existing certificate authorities. To do so, you need to define CA Connectors.

Certificates are attached to the user just like normal tokens. One token of type certificate always contains only one certificate.

If you have defined a CA connector you can upload a certificate signing request (CSR) via the Token Enroll Dialog in the WebUI.

![upload_csr](upload_csr.png)

Upload a certificate signing request

You need to choose the CA connector. The certificate will be signed by the CA accordingly. Just like all other tokens the certificate token can be attached to a user.

##### 4.4.2.2.1. Generating Signing Requests

You can also generate the signing request directly in your browser.

> Note:
> 
> This uses the keygen HTML-tag that is not supported by the Internet Explorer!

![generate_csr1](generate_csr1.png)

Generate a certificate signing request

When generating the certificate signing request this way the RSA keypair is generated on the client side in the browser.

The certificate is signed by the CA connected by the chosen CA connector.

![generate_csr2](generate_csr2.png)

Download or install the client certificate

Afterwards the user can install the certificate into the browser.

> Note:
> 
> By requiring OTP authentication for the users to login to the WebUI (see login_mode) you can have two factor authentication required for the user to be allowed to enroll a certificate.

#### 4.4.2.3. EMail

The token type email sends the OTP value in an EMail to the user. You can configure the EMail server in Email OTP Token.

![enroll_email](enroll_email.png)

Enroll an EMail token

When enrolling an EMail token, you only need to specify the email address of the user.

The EMail token is a challenge response token. I.e. when using the OTP PIN in the first authentication request, the sending of the EMail will be triggered and in a second authentication request the OTP value from the EMail needs to be presented.

For a more detailed insight see the code documentation Email Token.

#### 4.4.2.4. HOTP

The HOTP token is - together with the TOTP - the most common token. The HOTP Algorithm is defined in RFC4225. The HOTP token is an event base token. The HOTP algorithm has some parameter, like if the generated OTP value will be 6 digits or 8 digits or if the SHA1 oder the SHA256 hashing algorithm is used.

##### 4.4.2.4.1. Hardware tokens

There are many token vendors out there who are using the official algorithm to build and sell hardware tokens. You can get HOTP based hardware tokens in different form factors, as a normal key fob for your key ring or as a display card for your purse.

###### 4.4.2.4.1.1. Preseeded or Seedable

Usually the hardware tokens like keyfobs or display cards contain a secret key that was generated and implanted at the vendors factory. The vender ships the tokens and a seed file.

> Warning:
> 
> In this case privacyIDEA can not guarantee that the secret seed of the token is unique and if you are using a real strong factor.

privacyIDEA also supports the following seedable HOTP tokens:

* SafeNet eToken NG OTP
* SafeNet eToken Pass
* Yubikey in OATH mode
* Daplug

Those tokens can be initialized by privacyIDEA. Thus you can be sure, that only you are in possession of the secret seed.

###### 4.4.2.4.1.2. Experiences

The above mentioned hardware tokens are known to play well with privacyIDEA. In theory all OATH/HOTP tokens should work well with privacyIDEA. However, there are good experiences with Smartdisplayer OTP cards <span id="id1">[[1]](#smartdisplayer)</span> and Feitian C200 <span id="id2">[[2]](#feitian)</span> tokens.

##### 4.4.2.4.2. Software tokens

Besides the hardware tokens there are also software tokens, implemented as Apps for your smartphone. These software tokens allow are seedable, so there is no vendor, knowing the secret seed of your OTP tokens.

But software tokens are software after all on device prone to security issues.

###### 4.4.2.4.2.1. Experiences

The Google Authenticator can be enrolled easily in HOTP mode using the QR-Code enrollment Feature.

The Google Authenticator is available for iOS, Android and Blackberry devices.

##### 4.4.2.4.3. Enrollment

Default settings for HOTP tokens can be configured at HOTP Token Config.

![enroll_hotp1](enroll_hotp1.png)

Enroll an HOTP token

During enrollment you can choose, if the server should generate the key or if you have a key, that you can enter into the enrollment page.

As mentioned earlier, you can also choose the OTP length and the hash algoriothm.

![enroll_hotp2](enroll_hotp2.png)

If the server generated the secret seed, you can scan the QR-Code

After enrolling the token, the QR-Code, containing the secret seed, is displayed, so that you can scan this with your smartphone and import it to your app.

> [[1]](#id1): https://netknights.it/en/produkte/smartdisplayer/<span id="smartdisplayer"></span>
> 
> [[2]](#id2): https://netknights.it/en/produkte/oath-hotptotp/<span id="feitian"></span>

#### 4.4.2.5. Paper Token

The token type paper lets you print out a list of OTP values, which you can use to authenticate and cross of the list.

The paper token is based on the HOTP. I.e. you need to use one value after the other.

#### 4.4.2.6. Questionnaire Token

The administrator can define a list of questions and also how many answers to the questions a user needs to define.

During enrollment of such a question type token the user answers at least as many questions as specified with answers only he knows.

This token is a challenge response token. During authentication the user must give the token PIN and the a random question from the answered question is chosen. The user has to answer with the same answer he defined earlier.

> Note:
> 
> If the administrator changes the questions _after_ a token was enrolled, the enrolled token still works with the old questions and answers. I.e. an enrolled token is not affected by changing the questions by the administrator.

#### 4.4.2.7. RADIUS

The token type RADIUS forwards the authentication request to a RADIUS Server.

When forwarding the authentication request, you can change the username and mangle the password.

![enroll_radius](enroll_radius.png)

Enroll a RADIUS token

**Check the PIN locally**

If checked, the PIN of the token will be checked on the local server. If the PIN matches only the remaining part of the issued password will be sent to the RADIUS server.

**RADIUS Server**

The RADIUS server, to which the authentication request will be forwarded. You can specify the port like my.radius.server:1812.

**RADIUS User**

When forwarding the request to the RADIUS server, the authentication request will be issued for this user. If the user is left empty, the RADIUS request will be sent with the same user.

**RADIUS Secret**

The RADIUS secret for this RADIUS client.

> Note:
> 
> Using the RADIUS token you can design migration scenarios. When migrating from other (proprietary) OTP solutions, you can enroll a RADIUS token for the users. The RADIUS token points to the RADIUS server of the old solution. Thus the user can authenticate against privacyIDEA with the old, proprietary token, till he is enrolled a new token in privacyIDEA. The interesting thing is, that you also get the authentication request with the proprietary token in the audit log of privacyIDEA. This way you can have a scenario, where users are still using old tokens and other users are already using new (privacyIDEA) tokens. You will see all authentication requests in the pricacyIDEA system.

#### 4.4.2.8. Registration

(See Registration Code)

The registration token can be used to create a registration code for a user. This registration code can be sent via postal mail to the user, so that the user can use this registration code as a second factor to login to a portal.

After a one single use, the registration code is deleted and can not be used a second time.

> Note:
> 
> The registration code can only be enrolled via the API to provide automated smooth workflow to your needs.

For a more detailed insight see the code documentation Registration Code Token.

#### 4.4.2.9. Remote

The token type remote forwards the authentication request to another privacyIDEA Server.

When forwarding the authentication request, you can

* change the username
* change the resolver
* change the realm
* change the serial number

and mangle the password.

![enroll_remote](enroll_remote.png)

Enroll a Remote token

**Check the PIN locally**

If checked, the PIN of the token will be checked on the local server. If the PIN matches only the remaining part of the issued password will be sent to the remote privacyIDEA server.

**Remote Server**

The privacyIDEA server, to which the authentication request will be forwarded. The path /validate/check will be added automatically. So a sensible input would be https://my.other.server/.

**Remote Serial**

If the Remote Serial is specified the given password will be checked against the serial number on the remote privacyIDEA server. Usernames will be ignored.

**Remote User**

When forwarding the request to the remote server, the authentication request will be issued for this user.

**Remote Realm**

When forwarding the request to the remote server, the authentication request will be issued for this realm.

**Remote Resolver**

When forwarding the request to the remote server, the authentication request will be issued for this resolver.

> Note:
> 
> You can use Remote Serial to forward the request to a central privacyIDEA server, that only knows tokens but has no knowledge of users. Or you can use Remote Serial to forward the request to an existing to on localhost thus adding a second user to the same token.

#### 4.4.2.10. SMS

The token type sms sends the OTP value via an SMS service. You can configure the SMS service in SMS OTP Token.

![enroll_sms](enroll_sms.png)

Enroll an SMS token

When enrolling an SMS token, you only need to specify the mobile phone number.

SMS token is a challenge response token. I.e. when sending the OTP PIN in the first authentication request, the sending of the SMS will be triggered and in a second authentication request the OTP value from the SMS needs to be presented.

For a more detailed insight see the code documentation SMS Token.

#### 4.4.2.11. Spass - Simple Pass Token

The OTP component of the spass token is always true. Thus the user only needs to provide the OTP pin or the userstore password - depending on the policy settings.

For a more detailed insight see the code documentation SPass Token.

#### 4.4.2.12. SSH Keys

The token type sshkey is the public SSH key, that you can upload and assign to a user. The SSH key is only used for the application type SSH in conjunction with the Client machines concept.

A user or the administrator can upload the public SSH key and assign to a user.

![sshkey](sshkey.png)

Enroll an SSH key token

Paste the SSH key into the text area. The comment in the SSH key will be used as token comment. You can assign the SSH key to a user and then use the SSH key in Application Definitions SSH.

> Note:
> 
> This way you can manage SSH keys centrally, as you do not need to distribute the SSH keys to all machines. You rather store the SSH keys centrally in privacyIDEA and use **privacyidea-authorizedkeys** to fetch the keys in real time during the login process.

#### 4.4.2.13. TiQR

Starting with version 2.6 privacyIDEA supports the TiQR token. The TiQR token is a smartphone token, that can be used to login by only scanning a QR code.

The token is also enrolled by scanning a QR code.

![enroll_tiqr_1](enroll_tiqr_1.png)

Choose a user for the TiQR token

You can only enroll a TiQR token, when a user is selected.

> Note:
> 
> You can not enroll a TiQR token without assign the token to a user.

![enroll_tiqr_2](enroll_tiqr_2.png)

For more technical information about the TiQR token please see TiQR Token.

#### 4.4.2.14. TOTP

The TOTP token is - together with the HOTP - the most common token. The TOTP Algorithm is defined in RFC6238. The TOTP token is a time based token. Roughly speaking the TOTP algorithm is the same algorithm like the HOTP, where the event based counter is replaced by the unix timestamp.

The TOTP algorithm has some parameter, like if the generated OTP value will be 6 digits or 8 digits or if the SHA1 oder the SHA256 hashing algorithm is used and the timestep being 30 or 60 seconds.

##### 4.4.2.14.1. Hardware tokens

The information about preseeded token and seedable tokens is the same as described in the section about HOTP.

The only available seedable pushbutton TOTP token is the SafeNet eToken Pass. The Yubikey can be used as a TOTP token, but only in conjunction with a smartphone app, since the yubikey has not its own clock.

##### 4.4.2.14.2. Software tokens

###### 4.4.2.14.2.1. Experiences

The Google Authenticator and the FreeOTP token can be enrolled easily in TOTP mode using the QR-Code enrollment Feature.

The Google Authenticator is available for iOS, Android and Blackberry devices.

##### 4.4.2.14.3. Enrollment

Default settings for TOTP tokens can be configured at TOTP Token Config.

The enrollment is the same as described in HOTP. However, when enrolling TOTP token, you can specify some additional parameters.

![enroll_totp](enroll_totp.png)

Enroll an TOTP token

#### 4.4.2.15. U2F

Starting with version 2.7 privacyIDEA supports U2F tokens. The administrator or the user himself can register a U2F device and use this U2F token to login to the privacyIDEA web UI or to authenticate at applications.

When enrolling the token a key pair is generated and the public key is sent to privacyIDEA. During this process the user needs to prove that he is present by either pressing the button (Yubikey) or by replugging the device (Plug-up token).

The device is identified and assigned to the user.

> Note:
> 
> This is a normal token object which can also be reassigned to another user.
> 
> Note:
> 
> As the key pair is only generated virtually, you can register one physical device for several users.

For configuring privacyIDEA for the use of U2F token, please see U2F Token Config.

For further details and for information how to add this to your application you can see the code documentation at U2F Token.

#### 4.4.2.16. Yubico

The token type yubico authenticates against the Yubico Cloud mode. You need to configure this at Yubico Cloud mode.

![enroll_yubico](enroll_yubico.png)

Enroll a Yubico token

The token is enrolled by simply saving the Yubikey token ID in the token object. You can either enter the 12 digit ID or you can simply press the Yubikey button in the input field, which will also assign the token.

#### 4.4.2.17. Yubikey

The Yubikey is initialized with privacyIDEA and works in Yubicos own AES mode. It outputs a 44 character OTP value, consisting of a 12 character prefix and a 32 character OTP. But in contrast to the Yubico Cloud mode, in this mode the secret key is contained within the token and your own privacyIDEA installation.

If you have the time and care about privacy, you should prefer the Yubikey AES mode over the Yubico Cloud mode.

There are three possible ways to enroll a Yubikey token.

> Note:
> 
> We recommend that you use the privacyidea command line client, to initialize the Yubikeys. You can use the mass enrollment, which eases the process of initializing a whole bunch of tokens.

Run the command like this:

```
privacyidea -U https://your.privacyidea.server -a admin token \
yubikey_mass_enroll --yubimode YUBICO
```

This command initializes the token and stores the AES secret and prefix in privacyidea, so the token is immediatly useful. You can choose the slot with --yubislot. For further help call privcyidea yubikey_mass_enroll with the --help option.

The second way to enroll a yubikey token is also using yubikey_mass_enroll, but with the option --filename to write to token configuration into the specified file. The resulting file can then be imported into privacyidea: Select Tokens -> Import Tokens, select “OATH CSV” and the file you just created.

Third and last you can use this dialog to enroll a Yubikey AES mode token, if you have initialized the yubikey with the external ykpersonalize tool.

![enroll_yubikey](enroll_yubikey.png)

Enroll a Yubikey AES mode token

##### 4.4.2.17.1. Redirect api url to privacyideas /ttype/yubikey

Yubico servers use /wsapi/2.0/verify as the path in the validation URL. Some tools (e.g. Kolab 2fa) let the user/admin change the api host, but not the rest of the URL. Let’s redirect the api URL to privacyideas /ttype/yubikey - you’ll need to enable the following two lines in /etc/apache2/site-enabled/privacyidea.conf:

```
RewriteEngine on RewriteRule “^/wsapi/2.0/verify” “/ttype/yubikey” [PT]
```

If you use nginx there is a similar line provided as a comment to the nginx configuration as well.

### 4.4.3. Token configuration

Each token type can provide its own configuration dialog.

In this configuration dialog you can define default values for these token types.

![token-config](token-config.png)

Token Configuration: SMS

#### 4.4.3.1. Email OTP Token

![email](email.png)

Email Token configuration

The Email OTP token creates a OTP value and sends this OTP value to the email address of the uses. The Email can be triggered by authenticating with only the OTP PIN:

##### 4.4.3.1.1. First step

In the first step the user will enter his OTP PIN and the sending of the Email is triggered. The user is denied the access.

##### 4.4.3.1.2. Seconds step

In the second step the user authenticates with the OTP PIN and the OTP value he received via Email. The user is granted access.

Alternatively the user can authenticate with the transaction_id that was sent to him in the response during the first step and only the OTP value. The transaction_id assures that the user already presented the first factor (OTP PIN) successfully.

##### 4.4.3.1.3. Configuration Parameters

You can configure the mail parameters for the Email Token centrally at Config -> Tokens -> Email.

**Mail Server**

The name or IP address of the mail server that is used to send emails.

**Port**

The port of the mail server.

**Mail User**

If the mail server requires authentication you need to enter a username. If no username is entered, no authentication is performed on the mail server.

**Mail User Password**

The password of the mail username to send emails.

**Mail Sender Address**

The mail address of the mail sender. This needs to correspond to the Mail User.

**OTP validity time**

This is the time in seconds, for how long the sent OTP value is valid. If a user tries to authenticate with the sent OTP value after this time, authentication will fail.

**Use TLS**

Whether the mail server should use TLS.

#### 4.4.3.2. HOTP Token Config

![](hotp.png)

HOTP Token configuration

#### 4.4.3.3. SMS OTP Token

The SMS OTP token creates a OTP value and sends this OTP value to the mobile phone of the user. The SMS can be triggered by authenticating with only the OTP PIN:

##### 4.4.3.3.1. First step

In the first step the user will enter his OTP PIN and the sending of the SMS is triggered. The user is denied the access.

##### 4.4.3.3.2. Second step

In the second step the user authenticates with the OTP PIN and the OTP value he received via SMS. The user is granted access.

Alternatively the user can authenticate with the transaction_id that was sent to him in the response during the first step and only the OTP value. The transaction_id assures that the user already presented the first factor (OTP PIN) successfully.

A python SMS provider module defines how the SMS is sent. This can be done using an HTTP SMS Gateway. Most services like Clickatel or sendsms.de provide such a simple HTTP gateway. Another possibility is to send SMS via sipgate, which provides an XMLRPC API. The third possibility is to send the SMS via an SMTP gateway. The proovider receives a specially designed email and sends the SMS accordingly. The last possibility to send SMS is to use an attached GSM modem.

In the field SMS provider you can enter the SMS provider module, you wish to use. In the empty field hit the arrow-down key and you will get a list of the ready made modules.

In the SMS configuration text area you can enter the configuration, which contents is very much dependent on the selected provider module.

The HTTP and the Sipgate module provide a preset-button, which give you an idea of the configuration.

##### 4.4.3.3.3. HTTP provider

The HTTP provider can be used for any SMS gateway that provides a simple HTTP POST or GET request.

The following parameters can be used:

**URL**

This is the URL for the gateway.

**HTTP_Method**

Can be GET or POST.

**USERNAME and PASSWORD**

These are the username and the password if the HTTP request requires basic authentication.

**SMS_PHONENUMBER_KEY**

This is the name of the HTTP parameter that holds the mobile phone number of the recipient.

**SMS_TEXT_KEY**

This is the name of the HTTP parameter that holds the SMS text.

**RETURN_SUCCESS**

You can either use RETURN_SUCCESS or RETURN_FAIL. If the text of RETURN_SUCCESS is found in the HTTP response of the gateway privacyIDEA assumes that the SMS was sent successfully.

**RETURN_FAIL**

If the text of RETURN_FAIL is found in the HTTP response of the gateway privacyIDEA assumes that the SMS could not be sent and an error occurred.

**PROXY**

You can specify a proxy to connect to the HTTP gateway.

**PARAMETER**

This can contain a dictionary of arbitrary fixed additional parameters. Usually this would also contain an ID or a password to identify you as a sender.

###### 4.4.3.3.3.1. Example:

In case of the Clicaktell provider the configuration will look like this:

```

{ "URL" : "http://api.clickatell.com/http/sendmsg",

 "PARAMETER" : {

 "user":"YOU",

 "password":"YOUR PASSWORD",

 "api_id":"YOUR API ID"

 },

 "SMS_TEXT_KEY":"text",

 "SMS_PHONENUMBER_KEY":"to",

 "HTTP_Method":"GET",

 "RETURN_SUCCESS" : "ID"

}

```

This will consturct an HTTP GET request like this:

```

http://api.clickatell.com/http/sendmsg?user=YOU&password=YOU&\

 api_id=YOUR API ID&text=....&to=....

```

where text and to will contain the OTP value and the mobile phone number. privacyIDEA will assume a successful sent SMS if the response contains the text “ID”.

##### 4.4.3.3.4. Sipgate provider

The sipgate provider connects to https://samurai.sipgate.net/RPC2 and takes only two arguments USERNAME and PASSWORD. The arguments have to be passed in a dictionary like this:

```

{ "USERNAME" : "youruser",

 "PASSWORD" : "yourpassword" }

```

> Note:
> 
> You need to use double quotes around the values.

If you activate debug log level you will see the submitted SMS and the response content from the Sipgate gateway.

##### 4.4.3.3.5. SMTP provider

The SMTP provider sends an email to an email gateway. This is a specified, fixed mail address.

The mail should contain the phone number and the OTP value. The email gateway will send the OTP via SMS to the given phone number.

Up to version 2.9 the SMTP provider needs to be configured like this:

```

{"MAILSERVER": "localhost:25",

 "MAILTO": "recp@example.com",

 "MAILSENDER": "pi@example.com",

 "MAILUSER": "username",

 "MAILPASSWORD": "sosecret"}

```

Optional parameters are MAILUSER and MAILPASSWORD if the mailserver to send the email needs authentication.

This configuration is DEPRECATED.

Starting with privacyIDEA 2.10 you can use the system wide SMTP server configuration. The configuration looks like this:

```

{"MAILTO": "recp@example.com",

 "IDENTIFIER": "name-of-smtp-config"}

```

The default SUBJECT is set to <phone> and the default BODY to <otp>. You may change the SUBJECT and the BODY accordingly.

#### 4.4.3.4. TiQR Token Config

![tiqr](tiqr.png)

TiQR Token configuration

##### 4.4.3.4.1. TiQR Registration Server

You need at least enter the TiQR Registration Server. This is the URL of your privacyIDEA installation, that can be reached from the smartphone during enrollment. So your smartphone needs to be on the same LAN (WLAN) like the privacyIDEA server or the enrollment URL needs to be accessible from the internet.

You also need to specify the path, which is usually /ttype/tiqr.

During enrollment the parameter action=metadata and action=enrollment is added.

> Note:
> 
> We do not recommend putting the registration URL on the internet.

##### 4.4.3.4.2. TiQR Authentication Server

This is the URL that is used during authentication. This can be another URL than the Registration Server. If it is left blank, the URL of the Registration Server is used.

During authentication the parameter operation=login is added.

#### 4.4.3.5. TOTP Token Config

![totp](totp.png)

TOTP Token configuration

#### 4.4.3.6. U2F Token Config

##### 4.4.3.6.1. AppId

You need to configure the AppId of the privacyIDEA server. The AppId is define in the FIDO specification <span id="id3">[[1]](#fido)</span>.

The AppId is the URL of your privacyIDEA and used to find or create the right key pair on the U2F device. The AppId must correspond the the URL that is used to call the privacyIDEA server.

> Note:
> 
> if you register a U2F device with an AppId https://privacyidea.example.com and try to authenticate at https://10.0.0.1, the U2F authentication will fail.
> 
> Note:
> 
> The AppId must not contain any trailing slashes!

##### 4.4.3.6.2. Facets

If specifying the AppId as the FQDN you will only be able to authenticate at the privacyIDEA server itself or at any application in a sub directory on the privacyIDEA server. This is OK, if you are running a SAML IdP on the same server.

But if you also want to use the U2F token with other applications, you need to specify the AppId like this:

https://privacyidea.example.com/pi-url/ttype/u2f

pi-url is the path, if you are running the privacyIDEA instance in a sub folder.

/ttype/u2f is the endpoint that returns a trusted facets list. Trusted facets are other hosts in the domain example.com. You need to define a policy that contains a list of the other hosts (u2f_facets).

For more information on AppId and trusted facets see <span id="id4">[[1]](#fido)</span>.

For further details and for information how to add U2F to your application you can see the code documentation at U2F Token.

##### 4.4.3.6.3. Workflow

You can use a U2F token on privacyIDEA and other hosts in the same Domain. To do so you need to do the following steps:

1. Configure the AppId to reflect your privacyIDEA server:  
https://pi.your-network.com/ttype/u2f  
Add the path /ttype/u2f is crucial. Otherwise privacyIDEA will not return the trusted facets.
2. Define a policy with the list of trusted facets. (see u2f_facets). Add the FQDNs of the hosts to the policy:  
saml.your-network.com otherapp.your-network.com vpn.your-network.com  
> Note:
> 
> The privacyIDEA plugin for simpleSAMLphp supports U2F with privacyIDEA starting with version 2.8.
3. Now register a U2F token on https://pi.your-network.com. Due to the trusted facets you will also be able to use this U2F token on the other hosts.
4.Now got to https://saml.your-network.com and you will be able to authenticate with the very U2F token without any further registering.

**Footnotes**

> [1] ([1](#id3), [2](#id4)): https://fidoalliance.org/specs/fido-u2f-v1.0-nfc-bt-amendment-20150514/fido-appid-and-facets.html<span id="fido"></span>

#### 4.4.3.7. Yubico Cloud mode

The Yubico Cloud mode sends the One Time Password emitted by the yubikey to the Yubico Cloud service or another (possibly self hosted) validation server.

![yubico](yubico.png)

Configure the Yubico Cloud mode

To contact the Yubico Cloud service you need to get an API key and a Client ID from Yubico and enter these here in the config dialog. In that case you can leave the Yubico URL blank and privacyidea will use the Yubico servers.

You can use another validation host, e.g. a self hosted validation server. If you use privacyidea token type yubikey, you can use the URL https://<privacyideaserver>/ttype/yubikey, other validation servers might use https://<validationserver>/wsapi/2.0/verify. You’ll get the Client ID and API key from the configuration of your validation server.

You can get your own API key at <span id="id5>[[1]](#yubico)</span>.

> [[1]](#id5): https://upgrade.yubico.com/getapikey/<span id="yubico"></span>

#### 4.4.3.8. Yubikey AES mode

The Yubico AES mode uses the same kind of token as the Yubico Cloud service, but validates the OTP in your local privacyidea server. So the secrets stay local to your system and are not stored in Yubico’s Cloud service.

![yubikey](yubikey.png)

Configure the Yubikey AES mode

You can have more than one Client with a Client ID connect to your server. The Client ID starts with yubikey.apiid. and is followed by the API ID, which you’ll need to configure your clients. With create new API key you generate a new API for that specific Client ID. The API key is used to sign the validation request sent to the server and the server signs the answer too. That way tampering or MITM attacks might be detected. It is possible to validate token without the API key, but then the request and answer can’t be verify against the key. It is useful to use HTTPS for your validation requests, but this is another kind of protection.

OTP validation can either use the privacyidea API /validate/check or the Yubikey validation protocol /ttype/yubikey or - if enabled in your webserver configuration - /wsapi/2.0/verify.
