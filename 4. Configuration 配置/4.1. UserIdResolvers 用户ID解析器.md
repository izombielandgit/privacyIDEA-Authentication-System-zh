## 4.1. UserIdResolvers|用户ID解析器

Each organisation or company usually has its users managed at a central location. This is why privacyIDEA does not provide its own user management but rather connects to existing user stores.

每个组织或公司通常有其用户管理中心。这就是为什么privacyIDEA不提供自己的用户管理，而是连接到现有的用户源。

UserIdResolvers are connectors to those user stores, the locations, where the users are managed. Nowadays this can be LDAP directories or especially Active Directory, some times FreeIPA or the Redhat 389 service. But classically users are also located in files like /etc/passwd on standalone unix systems. Web services often use SQL databases as user store.

Today with many more online cloud services SCIM is also an uprising protocol to access userstores.

用户ID解析器是这些用户源的连接器。这些用户源可以是LDAP，Active Directory，FreeIPA或Redhat 389服务。但是经典用户也位于独立的UNIX系统上/etc/passwd文件中。Web服务通常使用SQL数据库作为用户存储。今天越来越多使用的在线云服务SCIM也是一个访问用户源的协议。

privacyIDEA already comes with UserIdResolvers to talk to all these user stores:

privacyIDEA已经附带用户ID解析器来与所有这些用户源交互：

* Flatfile resolver,(平面文件解析器)
* LDAP resolver,(LDAP解析器)
* SQL resolver,(SQL解析器)
* SCIM resolver.(SCIM解析器)

> Note:
> 
> New resolver types (python modules) can be added easily. See the module section for this (UserIdResolvers).
> 
> 注：
> 
> 可以很容易地添加新的解析器类型（python模块）。请参阅module章节（UserIdResolvers）。

You can create as many UserIdResolvers as you wish and edit existing resolvers. When you have added all configuration data, most UIs of the UserIdResolvers have a button “Test resolver”, so that you can test your configuration before saving it.

您可以创建任意数量的用户ID解析器，并编辑现有的解析器。添加所有配置数据后，用户ID解析器的大多数界面都有一个“Test resolver”按钮，以便您可以在保存配置之前对其进行测试。

Starting with privacyIDEA 2.4 resolvers can be editable, i.e. you can edit the users in the user store. Read more about this at Manage Users.

从privacyIDEA 2.4开始可以编辑解析器，即您可以编辑用户源中的用户。有关详情，请参阅Manage Users。

> Note:
> 
> Using the policy authentication:otppin=userstore users can authenticate with the password from their user store, being the LDAP password, SQL password or password from flat file.
> 注：
> 使用认证策略：`otppin=userstore`，用户可以使用用户源中的密码进行认证，如LDAP密码，SQL密码或来自平面文件的密码。

### 4.1.1. Flatfile resolver

平面文件解析器

Flatfile resolvers read files like /etc/passwd.

平面文件解析器从文件中读取信息，如/etc/passwd等。

> Note:
> 
> The file /etc/passwd does not contain the unix password. Thus, if you create a flatfile resolver from this file the functionality with otppin=userstore is not available. You can create a flatfile with passwords using the tool privacyidea-create-pwidresolver-user.
> 
> 注：
> 
> /etc/passwd文件不包含unix密码。因此，如果从此文件创建平面文件解析器，则`otppin=userstore`的功能不可用。您可以使用工具`privacyidea-create-pwidresolver-user`创建带有密码的平面文件。

Create a flat file like this:

像这样创建一个平面文件：

```
privacyidea-create-pwidresolver-user -u user2 -i 1002 >> /your/flat/file
```

### 4.1.2. LDAP resolver

LDAP解析器

The LDAP resolver can be used to access any kind of LDAP service like OpenLDAP, Active Directory, FreeIPA, Penrose, Novell eDirectory.

LDAP解析器可用于访问任何类型的LDAP服务，如OpenLDAP，Active Directory，FreeIPA，Penrose，Novell eDirectory。

![ldap-resolver](../Contents/ldap-resolver.png)

LDAP resolver configuration

In case of Active Directory connections you might need to check the box No anonymous referral chasing. The underlying LDAP library is only able to do anonymous referral chasing. Active Directory will produce an error in this case <span id="id4">[[1]](#adreferrals)</span>.

The Server URI can contain a comma separated list of servers. The servers are used to create a server pool and are used with a round robin strategy <span id="id5">[[3]](#serverpool)</span>.

Example:

```
ldap://server1, ldaps://server2:1636, server3, ldaps://server4
```

This will create LDAP requests to

* server1 on port 389
* server2 on port 1636 using SSL
* server3 on port 389
* server4 on port 636 using SSL.

The Bind Type with Active Directory can either be chosen as “Simple” or as “NTLM”.

> Note:
> 
> When using bind type “Simple” you need to specify the Bind DN like cn=administrator,cn=users,dc=domain,dc=name. When using bind type “NTLM” you need to specify Bind DN like DOMAINNAME\username.

The LoginName attribute is the attribute that holds the loginname. It can be changed to your needs.

The searchfilter and the userfilter are used for forward and backward search the object in LDAP.

The searchfilter is used to list all possible users, that can be used in this resolver.

The userfilter is used to find the LDAP object for a given loginname. This is why the userfilter contains the python string replacement parameter %s, which will be filled with the given loginname to find the LDAP object.

The attribute mapping maps LDAP object attributes to user attributes in privacyIDEA. privacyIDEA knows the following attributes:

* username (mandatory),
* phone,
* mobile,
* email,
* surname,
* givenname,
* password
* accountExpires.

The above attributes are used for privacyIDEA’s normal functionality and are listed in the userview. However, with a SAML authentication request user attributes can be returned. (see SAML Attributes). To return arbitrary attributes from the LDAP you can add additional keys to the attribute mapping with a key, you make up and the LDAP attribute like:

“homedir”: “homeDirectory”, “studentID”: “objectGUID”

“homeDirectory” and “objectGUID” being the attributes in the LDAP directory and “homedir” and “studentID” the keys returned in a SAML authentication request.

The UID Type is the unique identifier for the LDAP object. If it is left blank, the distinguished name will be used. In case of OpenLDAP this can be entryUUID and in case of Active Directory objectGUID.

> Note:
> 
> The attributes entryUUID and objectGUID are case sensitive!

#### 4.1.2.1. Modifying users

Starting with privacyIDEA 2.12 you can define the LDAP resolver as editable. I.e. you can create and modify users from within privacyIDEA.

There are two additional configuration parameters for this case.

DN Template defines how the DN of the new LDAP object should be created. You can use username, surname, givenname and basedn to create the distiguished name.

Examples:

CN=<givenname> <surname>,<basedn>

CN=<username>,OU=external users,<basedn>

uid=<username>,ou=users,o=example,c=com

Object Classes defines which object classes the user should be assigned to. This is a comma separated list. The usual object classes for Active Directory are

top, person, organizationalPerson, user, inetOrgPerson

#### 4.1.2.2. Expired Users

You may set

“accountExpires”: “accountExpires”

in the attribute mapping for Microsoft Active Directories. You can then call the user listing API with the parameter accountExpires=1 and you will only see expired accounts.

This functionality is used with the script privacyidea-expired-users.

### 4.1.3. SQL resolver

SQL解析器

The SQL resolver can be used to retrieve users from any kind of SQL database like MySQL, PostgreSQL, Oracle, DB2 or sqlite.

![sql-resolver](../Contents/sql-resolver.png)

SQL resolver configuration

In the upper frame you need to configure the SQL connection. The SQL resolver uses SQLAlchemy internally. In the field Driver you need to set a driver name as defined by the SQLAlchemy dialects like “mysql” or “postgres”.

In the SQL attributes frame you can specify how the users are identified.

The Database table contains the users.

> Note:
> 
> At the moment only one table is supported, i.e. if some of the user data like email address or telephone number is located in a second table, those data can not be retrieved.

The Limit is the SQL limit for a userlist request. This can be important if you have several thousand user entries in the table.

The Attribute mapping defines which table column should be mapped to which privayIDEA attribute. The known attributes are:

* userid (mandatory),
* username (mandatory),
* phone,
* mobile,
* email,
* givenname,
* surname,
* password.

The password attribute is the database column that contains the user password. This is used, if you are doing user authentication against the SQL database.

> Note:
> 
> There is no standard way to store passwords in an SQL database. There are several different ways to do this. privacyIDEA supports the most common ways like Wordpress hashes starting with $P or $S. Secure hashes starting with {SHA} or salted secure hashes starting with {SSHA}, {SSHA256} or {SSHA512}. Password hashes of length 64 are interpreted as OTRS sha256 hashes.

You can add an additional Where statement if you do not want to use all users from the table.

The poolSize and poolTimeout determine the pooling behaviour. The poolSize (default 5) determine how many connections are kept open in the pool. The poolTimeout (default 10) specifies how long the application waits to get a connection from the pool.

> Note:
> 
> The Additional connection parameters refer to the SQLAlchemy connection but are not used at the moment.

### 4.1.4. SCIM resolver

SCIM解析器

SCIM is a “System for Cross-domain Identity Management”. SCIM is a REST-based protocol that can be used to ease identity management in the cloud.

The SCIM resolver is tested in basic functions with OSIAM <span id="id6">[[2]](#osiam)</span>, the “Open Source Idenitty & Access Management”.

To connect to a SCIM service you need to provide a URL to an authentication server and a URL to the resource server. The authentication server is used to authenticate the privacyIDEA server. The authentication is based on a client name and the Secret for this client.

Userinformation is then retrieved from the resource server.

The available attributes for the Attribute mapping are:

* username (mandatory),
* givenname,
* surname,
* phone,
* mobile,
* email.

**Footnotes**

> [[1]](#id4): http://blogs.technet.com/b/ad/archive/2009/07/06/referral-chasing.aspx<span id="adreferrals"></span>
> 
> [[2]](#id6): http://www.osiam.org<span id="osiam"></span>
> 
> [[3]](#id5): https://github.com/cannatag/ldap3/blob/master/docs/manual/source/servers.rst#server-pool<span id="serverpool"></span>